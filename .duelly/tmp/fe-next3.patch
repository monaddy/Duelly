diff --git a/src/components/PixiBoard.tsx b/src/components/PixiBoard.tsx
--- a/src/components/PixiBoard.tsx
+++ b/src/components/PixiBoard.tsx
@@
+// Ensure Pixi v7 polygon shim is registered for legacy code paths.
+import '../shims/pixi-graphics-polygon';
@@
-    // legacy pointer affordance
-    piece.buttonMode = true;
+    // Pixi v7: buttonMode removed; use eventMode/cursor
+    piece.eventMode = 'static';
+    piece.cursor = 'pointer';
@@
-  app.destroy(true, { children: true, texture: true, baseTexture: true });
+  // Pixi v7: 'baseTexture' option renamed to 'textureSource'
+  app.destroy(true, { children: true, texture: true, textureSource: true });
@@
-  // draw triangles using Graphics.polygon (v6 API)
-  g.polygon([a.x, a.y, b.x, b.y, c.x, c.y]);
-  g.polygon([d.x, d.y, e.x, e.y, f.x, f.y]);
+  // Keep polygon calls; runtime shim provides .polygon in v7 and we add TS augmentation.
+  g.polygon([a.x, a.y, b.x, b.y, c.x, c.y]);
+  g.polygon([d.x, d.y, e.x, e.y, f.x, f.y]);
@@
-  const to = moveAttempt.to;
+  // Guard: 'to' can be undefined during drag; avoid TS2322/runtime errors.
+  const to = moveAttempt?.to ?? from;
diff --git a/src/types/pixi-v7-augment.d.ts b/src/types/pixi-v7-augment.d.ts
new file mode 100644
--- /dev/null
+++ b/src/types/pixi-v7-augment.d.ts
@@
+/* Ambient type augmentation for Pixi v7 to keep legacy code compiling.
+ * Runtime implementation is provided by src/shims/pixi-graphics-polygon.ts.
+ */
+import 'pixi.js';
+declare module 'pixi.js' {
+  interface Graphics {
+    polygon(points: number[] | import('pixi.js').IPointData[], close?: boolean): this;
+  }
+  interface DestroyOptions {
+    textureSource?: boolean;
+  }
+}
diff --git a/src/utils/fairness.ts b/src/utils/fairness.ts
--- a/src/utils/fairness.ts
+++ b/src/utils/fairness.ts
@@
-  const signature = await crypto.subtle.sign(alg, key, data);
+  const signature = await crypto.subtle.sign(alg, key, toUint8(data));
@@
+// --- DUELLY fairness: normalize BufferSource for WebCrypto ---
+function toUint8(src: ArrayBufferView | ArrayBufferLike): Uint8Array {
+  if (src instanceof Uint8Array) return new Uint8Array(src); // copy to detach
+  if (ArrayBuffer.isView(src)) {
+    const v = src as ArrayBufferView;
+    return new Uint8Array(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
+  }
+  return new Uint8Array(new Uint8Array(src as ArrayBufferLike));
+}
